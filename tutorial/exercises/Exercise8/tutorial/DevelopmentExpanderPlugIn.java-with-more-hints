/*
 * <copyright>
 *  Copyright 1997-2000 Defense Advanced Research Projects
 *  Agency (DARPA) and ALPINE (a BBN Technologies (BBN) and
 *  Raytheon Systems Company (RSC) Consortium).
 *  This software to be used only in accordance with the
 *  COUGAAR licence agreement.
 * </copyright>
 */
package tutorial;

import org.cougaar.core.cluster.IncrementalSubscription;
import org.cougaar.domain.planning.ldm.plan.*;
import org.cougaar.core.plugin.util.PlugInHelper;
import org.cougaar.util.UnaryPredicate;
import java.util.Enumeration;
import java.util.Vector;


/**
 * This ALP PlugIn expands tasks of verb "CODE"
 * into workflows of subtasks:
 * DESIGN
 * DEVELOP
 * TEST
 * @author ALPINE (alpine-software@bbn.com)
 * @version $Id: DevelopmentExpanderPlugIn.java-with-more-hints,v 1.2 2000-12-18 15:41:03 wwright Exp $
 **/
public class DevelopmentExpanderPlugIn extends org.cougaar.core.plugin.SimplePlugIn
{
  // Subscription for all 'CODE' tasks
  private IncrementalSubscription allCodeTasks;

  // Subscription for all of my expansions
  private IncrementalSubscription allMyExpansions;

  // Subscription for all subtasks that I make
  private IncrementalSubscription allSubTasks;

  // This predicate matches all tasks with verb "CODE"
  private UnaryPredicate allCodeTasksPredicate = new UnaryPredicate() {
    public boolean execute(Object o) {
      boolean ret = false;
      if (o instanceof Task) {
        Task t = (Task)o;
        ret = t.getVerb().equals("CODE");
      }
      return ret;
    }
  };

  // This predicate matches all of my subtsks
  private UnaryPredicate allSubTasksPredicate = new UnaryPredicate() {
    public boolean execute(Object o) {
      boolean ret = false;
      if (o instanceof Task) {
        Task t = (Task)o;
        Verb v = t.getVerb();
        ret = v.equals("DESIGN") || v.equals("DEVELOP") || v.equals("TEST");
      }
      return ret;
    }
  };

  /**
   * Predicate that matches all Expansion of CODE tasks
   * todo: subscribe to expansions of CODE tasks
   */
  private UnaryPredicate expansionPredicate = new UnaryPredicate() {
    public boolean execute(Object o) {
// hints: use Expansion.getTask() to get the parent task
// more hints:       if (o instanceof Expansion)
// more hints:       {
// more hints:         Expansion exp = (Expansion)o;
// more hints:         return (exp.getTask().getVerb().equals(Verb.getVerb("CODE")));
// more hints:       }
      return false;
    }
  };

  /**
   * Establish subscription for CODE tasks
   **/
  public void setupSubscriptions() {
    allCodeTasks =
      (IncrementalSubscription)subscribe(allCodeTasksPredicate);
    allMyExpansions = (IncrementalSubscription)subscribe(expansionPredicate);
    allSubTasks =(IncrementalSubscription)subscribe(allSubTasksPredicate);
  }

  /**
   * Top level plugin execute loop.
   **/
  public void execute() {
    System.out.println("DevelopmentExpanderPlugIn::execute");

    // todo: Now look through all new 'CODE' tasks
    // and expand
    for(Enumeration e = allCodeTasks.getAddedList();e.hasMoreElements();)
    {
// more hints:       Task task = (Task) e.nextElement();

      // todo: Create expansion and workflow to represent the expansion
      // of this task.  Publish the expansion, workflow and subtasks.
// more hints:       NewWorkflow new_wf = theLDMF.newWorkflow();
// more hints:       new_wf.setParentTask(task);

// more hints:       plan(new_wf);

// more hints:       AllocationResult estAR = null;
// more hints:       Expansion new_exp =
// more hints:         theLDMF.createExpansion(task.getPlan(), task, new_wf, estAR);
// more hints:       publishAdd(new_wf);
// more hints:       publishAdd(new_exp);
    }

    // Now look through all changed expansions and update the allocation result
    Enumeration exps = allMyExpansions.elements();
    while (exps.hasMoreElements()) {
       checkForReplan((Expansion)exps.nextElement());
    }
// todo: report allocation results
// hints: use PlugInHelper.updateAllocationResult to report back results
// more hints:    PlugInHelper.updateAllocationResult(allMyExpansions);
  }

  /**
   * Create a task.
   * @param verb The string for the verb for the task.
   * @param parent_task The task being expanded
   * @param start the start month for the task
   * @param deadline the end month for the task
   * @param duration the length (in months) of the task
   * @param workflow the workflow being filled out
   * @return A new sub-task member of the workflow
   */
  private NewTask makeTask(String verb, Task parent_task, Workflow wf) {
    Task task = new_wf.getParentTask();
    NewTask new_task = theLDMF.newTask();

    new_task.setParentTask(parent_task);
    new_task.setWorkflow(wf);

    // Set the verb as given
    new_task.setVerb(Verb.getVerb(verb));

    // Copy important fields from the parent task
    new_task.setPlan(parent_task.getPlan());
    new_task.setDirectObject(parent_task.getDirectObject());
    new_task.setPrepositionalPhrases(parent_task.getPrepositionalPhrases());

    return new_task;
  }

  /**
   * This convenience function is complete as-is
   */
  private void setPreferences(NewTask new_task,int start, int duration, int deadline) {
    // Establish preferences for task
    Vector preferences = new Vector();

    // Add a start_time, end_time, and duration strict preference
    ScoringFunction scorefcn = ScoringFunction.createStrictlyAtValue
      (new AspectValue(AspectType.START_TIME, start));
    Preference pref =
      theLDMF.newPreference(AspectType.START_TIME, scorefcn);
    preferences.add(pref);

    scorefcn = ScoringFunction.createStrictlyAtValue
      (new AspectValue(AspectType.END_TIME, deadline));
    pref = theLDMF.newPreference(AspectType.END_TIME, scorefcn);
    preferences.add(pref);

    scorefcn = ScoringFunction.createStrictlyAtValue
      (new AspectValue(AspectType.DURATION, duration));
    pref = theLDMF.newPreference(AspectType.DURATION, scorefcn);
    preferences.add(pref);

    new_task.setPreferences(preferences.elements());
  }

  /**
   * This convenience function is complete as-is
   */
  private void setPreferences(NewTask new_task, int duration, int deadline) {
    // Establish preferences for task (just duration and deadline, not start)
    Vector preferences = new Vector();

    ScoringFunction scorefcn = ScoringFunction.createStrictlyAtValue
      (new AspectValue(AspectType.DURATION, duration));
    Preference pref = theLDMF.newPreference(AspectType.DURATION, scorefcn);
    preferences.add(pref);

    scorefcn = ScoringFunction.createStrictlyAtValue
      (new AspectValue(AspectType.END_TIME, deadline));
    pref = theLDMF.newPreference(AspectType.END_TIME, scorefcn);
    preferences.add(pref);

    new_task.setPreferences(preferences.elements());
  }

  /**
   * Determine if we should replan this expansion because something changed
   */
  private void checkForReplan(Expansion exp) {
  // todo: get the next pending constraint and update the constrained task's preferences
// hints: use Workflow.getNextPendingConstraint  to get the next constraint to work on
// hints: use SettableConstraintEvent.setValue and Constraint.computeValidConstrainedValue
// hints:   to update the preferences on the constrain-ed task
// hints: Don't forget to publishAdd the constrained task
// more hints:    Workflow wf = exp.getWorkflow();
// more hints:    Constraint c = wf.getNextPendingConstraint();
// more hints:    if (c != null) {
// more hints:      ConstraintEvent ced = c.getConstrainedEventObject();
// more hints:      if (ced instanceof SettableConstraintEvent)
// more hints:      {
// more hints:        ((SettableConstraintEvent)ced).setValue(c.computeValidConstrainedValue());
//System.out.println("START_TIME on "+c.getConstrainedTask().getVerb()+" set to "+getStartTime(c.getConstrainedTask()));
// more hints:        publishAdd(c.getConstrainedTask());
// more hints:      }
    }

  }

  /**
   * This VERY primitive scheduler just keeps moving the whole workflow later until it can be scheduled
   */
  private void plan(NewWorkflow new_wf) {
    int latest_end = getEndTime(task);

    int start_month    = getStartTime(task);
    int deadline_month = latest_end;

    // todo : use makeTask and setPreferences convenience functions to create a "DESIGN" task
    // assign one month for design
    int this_task_duration = 1;
// hints: The first task should have a START_TIME preference.  Use the setPreferneces (below) that takes 4 arguments
// hints: Don't forget to publish the new subtask and add it to the Workflow
// more hints:    NewTask t1 = makeTask("DESIGN", task, new_wf);
// more hints:    setPreferences(t1, start_month, this_task_duration, deadline_month);
// more hints:    publishAdd(t1);      // Add the task to the PLAN
// more hints:    new_wf.addTask(t1);  // Add the task to the Workflow

    // assign three months for development
    this_task_duration = 3;
// hints: The 2nd and 3rd tasks should not have a START_TIME preference yet.  Use the setPreferneces (below) that takes 3 arguments
// hints: don't publish the 2nd and 3rd tasks yet. (see checkForReplan(above))
// more hints:    NewTask t2 = makeTask("DEVELOP", task, new_wf);
// more hints:    setPreferences(t2, this_task_duration, deadline_month);
// more hints:    new_wf.addTask(t2);  // Add the task to the Workflow

    // testing takes two months
    this_task_duration = 2;
// hints: The 2nd and 3rd tasks should not have a START_TIME preference yet.  Use the setPreferneces (below) that takes 3 arguments
// hints: don't publish the 2nd and 3rd tasks yet. (see checkForReplan(above))
// more hints:    NewTask t3 = makeTask("TEST", task, new_wf);
// more hints:    setPreferences(t3, this_task_duration, deadline_month);

// more hints:    new_wf.addTask(t3);  // Add the task to the Workflow

    // Add constraints onto the workflow that t1 < t2 < t3
// more hints:    Vector constraints = new Vector();

    // End(t1) must be before Start(t2)
// more hints:    NewConstraint c1 = theLDMF.newConstraint();
// more hints:    c1.setConstrainingTask(t1);
// more hints:    c1.setConstrainingAspect(AspectType.END_TIME);
// more hints:    c1.setConstrainedTask(t2);
// more hints:    c1.setConstrainedAspect(AspectType.START_TIME);
// more hints:    c1.setConstraintOrder(Constraint.BEFORE);
// more hints:    constraints.addElement(c1);

    // End(t2) must be before Start(t3)
// more hints:    NewConstraint c2 = theLDMF.newConstraint();
// more hints:    c2.setConstrainingTask(t2);
// more hints:    c2.setConstrainingAspect(AspectType.END_TIME);
// more hints:    c2.setConstrainedTask(t3);
// more hints:    c2.setConstrainedAspect(AspectType.START_TIME);
// more hints:    c2.setConstraintOrder(Constraint.BEFORE);
// more hints:    constraints.addElement(c2);

    // set the constraints on the workflow
// more hints:    new_wf.setConstraints(constraints.elements());
  }

  /**
   * Get the END_TIME preference for the task
   */
  private int getEndTime(Task t) {
    double end = 0.0;
    Preference pref = getPreference(t, AspectType.END_TIME);
    if (pref != null)
      end = pref.getScoringFunction().getBest().getAspectValue().getValue();
    return (int)end;
  }

  /**
   * Get the START_TIME preference for the task
   */
  private int getStartTime(Task t) {
    double start = 0.0;
    Preference pref = getPreference(t, AspectType.START_TIME);
    if (pref != null)
      start = pref.getScoringFunction().getBest().getAspectValue().getValue();
    return (int)start;
  }
  /**
   * Get the DURATION preference for the task
   */
  private int getDuration(Task t) {
    double start = 0.0;
    Preference pref = getPreference(t, AspectType.DURATION);
    if (pref != null)
      start = pref.getScoringFunction().getBest().getAspectValue().getValue();
    return (int)start;
  }
  /**
   * Return the preference for the given aspect
   * @param task for which to return given preference
   * @paran int aspect type
   * @return Preference (or null) from task for given aspect
   **/
  private Preference getPreference(Task task, int aspect_type)
  {
    Preference aspect_pref = null;
    for(Enumeration e = task.getPreferences(); e.hasMoreElements();)
    {
      Preference pref = (Preference)e.nextElement();
      if (pref.getAspectType() == aspect_type) {
        aspect_pref = pref;
        break;
      }
    }
    return aspect_pref;
  }
}
